<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>霓虹俄罗斯方块</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    .wrapper {
      width: 760px;
      max-width: 100vw;
      padding: 20px 24px 24px;
      border-radius: 18px;
      background: rgba(15, 23, 42, 0.96);
      box-shadow:
        0 0 0 1px rgba(148, 163, 184, 0.4),
        0 24px 80px rgba(15, 23, 42, 0.95),
        0 0 40px rgba(56, 189, 248, 0.3);
      position: relative;
      overflow: hidden;
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
      column-gap: 18px;
      row-gap: 16px;
    }
    .wrapper::before {
      content: "";
      position: absolute;
      inset: -1px;
      pointer-events: none;
      background:
        radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.35), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(129, 140, 248, 0.3), transparent 55%);
      mix-blend-mode: screen;
      opacity: 0.7;
    }
    .header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      z-index: 1;
    }
    .title-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .title-main {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .title-main span {
      background: linear-gradient(120deg, #38bdf8, #a855f7, #f97316);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .title-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e, #15803d);
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.9);
      animation: pulse 1.6s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.55; }
    }
    .subtitle {
      font-size: 12px;
      color: #9ca3af;
    }
    .score-panel {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
    }
    .badge {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.75);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.4), rgba(15, 23, 42, 0.95));
    }
    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 9px rgba(34, 197, 94, 0.9);
    }
    .score-box {
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.35), rgba(15, 23, 42, 0.96));
      display: flex;
      gap: 12px;
      align-items: baseline;
    }
    .score-item-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #9ca3af;
    }
    .score-item-value {
      font-size: 18px;
      font-weight: 650;
    }
    .score-item-value.best {
      color: #fbbf24;
    }

    .left {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .game-container {
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background:
        radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.32), transparent 60%),
        radial-gradient(circle at 100% 100%, rgba(236, 72, 153, 0.25), transparent 60%),
        linear-gradient(145deg, #020617, #020617);
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    canvas {
      display: block;
      border-radius: 10px;
      background:
        linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(2, 6, 23, 1)),
        radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.35), transparent 60%);
      box-shadow:
        inset 0 0 0 1px rgba(15, 23, 42, 0.9),
        0 0 40px rgba(56, 189, 248, 0.4);
    }
    .right {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 14px;
      font-size: 13px;
      color: #d1d5db;
    }
    .panel {
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 10px 12px;
      background: radial-gradient(circle at 0 0, rgba(15, 23, 42, 0.4), rgba(15, 23, 42, 0.96));
    }
    .panel-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #9ca3af;
      margin-bottom: 6px;
    }
    .next-box {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 0 2px;
    }
    #nextCanvas {
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.25), transparent 60%);
      border-radius: 8px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }
    .key {
      border-radius: 7px;
      border: 1px solid rgba(148, 163, 184, 0.75);
      padding: 2px 7px;
      font-size: 11px;
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.4), rgba(15, 23, 42, 0.96));
      color: #e5e7eb;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
    }
    .buttons {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 6px 13px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .btn-primary {
      background: linear-gradient(135deg, #22c55e, #4ade80);
      color: #052e16;
      box-shadow:
        0 0 14px rgba(34, 197, 94, 0.7),
        0 10px 28px rgba(22, 163, 74, 0.75);
    }
    .btn-secondary {
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.8), rgba(30, 64, 175, 0.95));
      color: #e5e7eb;
      box-shadow:
        0 0 18px rgba(56, 189, 248, 0.7),
        0 8px 24px rgba(15, 23, 42, 0.9);
    }
    .status {
      margin-top: 4px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #9ca3af;
    }
    .status-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #38bdf8;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
    }

    .overlay {
      position: absolute;
      inset: 10px;
      border-radius: 10px;
      background: radial-gradient(circle at 50% 15%, rgba(15, 23, 42, 0.15), rgba(15, 23, 42, 0.96));
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: #e5e7eb;
      z-index: 2;
      text-align: center;
      padding: 0 12px;
    }
    .overlay.hidden {
      display: none;
    }
    .overlay-title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: linear-gradient(120deg, #38bdf8, #a855f7, #f97316);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .overlay-subtitle {
      font-size: 13px;
      color: #9ca3af;
    }
    .overlay-stats {
      display: flex;
      gap: 18px;
      font-size: 13px;
    }
    .overlay-stat-item {
      display: flex;
      flex-direction: column;
      gap: 3px;
      align-items: center;
    }
    .overlay-stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #9ca3af;
    }
    .overlay-stat-value {
      font-size: 18px;
      font-weight: 650;
    }
    .overlay-hint {
      font-size: 11px;
      color: #9ca3af;
      max-width: 260px;
    }
    .overlay-hint code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      font-size: 11px;
    }

    @media (max-width: 720px) {
      .wrapper {
        grid-template-columns: minmax(0, 1fr);
        row-gap: 12px;
        border-radius: 0;
        height: 100vh;
      }
      body {
        align-items: stretch;
      }
      .right {
        order: 3;
      }
      .left {
        order: 2;
      }
      .header {
        order: 1;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <div class="title-block">
        <div class="title-main">
          <div class="title-dot"></div>
          <span>NEON TETRIS</span>
        </div>
        <div class="subtitle">霓虹俄罗斯方块 · 使用方向键或 WSAD 控制，空格快速下落</div>
      </div>
      <div class="score-panel">
        <div class="badge">
          <span class="badge-dot"></span>
          SESSION · LIVE
        </div>
        <div class="score-box">
          <div>
            <div class="score-item-label">SCORE</div>
            <div class="score-item-value" id="score">0</div>
          </div>
          <div>
            <div class="score-item-label">LINES</div>
            <div class="score-item-value" id="lines">0</div>
          </div>
          <div>
            <div class="score-item-label">BEST</div>
            <div class="score-item-value best" id="bestScore">0</div>
          </div>
        </div>
      </div>
    </div>

    <div class="left">
      <div class="game-container">
        <canvas id="gameCanvas" width="240" height="480"></canvas>
        <div class="overlay" id="overlay">
          <div class="overlay-title" id="overlayTitle">NEON TETRIS</div>
          <div class="overlay-subtitle" id="overlaySubtitle">按回车或空格开始游戏</div>
          <div class="overlay-stats">
            <div class="overlay-stat-item">
              <div class="overlay-stat-label">LAST SCORE</div>
              <div class="overlay-stat-value" id="overlayScore">0</div>
            </div>
            <div class="overlay-stat-item">
              <div class="overlay-stat-label">BEST SCORE</div>
              <div class="overlay-stat-value" id="overlayBest">0</div>
            </div>
          </div>
          <div class="overlay-hint">
            操作：<code>← →</code> 左右移动，<code>↑ / W</code> 旋转，<code>↓ / S</code> 加速下落，<code>空格</code> 快速落到底，<code>P</code> 暂停/继续。
          </div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="panel-title">NEXT PIECE</div>
        <div class="next-box">
          <canvas id="nextCanvas" width="120" height="120"></canvas>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">CONTROLS</div>
        <div>支持方向键或 WSAD：</div>
        <div class="controls">
          <span class="key">← / A</span>
          <span class="key">→ / D</span>
          <span class="key">↓ / S</span>
          <span class="key">↑ / W 旋转</span>
          <span class="key">Space 快速下落</span>
          <span class="key">P 暂停</span>
        </div>
        <div class="buttons">
          <button class="btn-secondary" id="pauseBtn">⏸ 暂停</button>
          <button class="btn-primary" id="restartBtn">⟳ 重新开始</button>
        </div>
        <div class="status">
          <span class="status-dot"></span>
          <span id="statusText">等待开始 · 按回车开始</span>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">HINT</div>
        <div style="font-size: 12px; color: #9ca3af;">
          - 连续消除多行会获得更高得分。<br />
          - 速度会随消除行数逐渐提升。<br />
          - 建议使用空格快速下落提高效率。
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const nextCanvas = document.getElementById("nextCanvas");
      const nextCtx = nextCanvas.getContext("2d");

      const scoreEl = document.getElementById("score");
      const linesEl = document.getElementById("lines");
      const bestScoreEl = document.getElementById("bestScore");
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySubtitle = document.getElementById("overlaySubtitle");
      const overlayScoreEl = document.getElementById("overlayScore");
      const overlayBestEl = document.getElementById("overlayBest");
      const pauseBtn = document.getElementById("pauseBtn");
      const restartBtn = document.getElementById("restartBtn");
      const statusText = document.getElementById("statusText");

      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 24;

      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;

      const SHAPES = {
        I: [
          [[0, 0, 0, 0],
           [1, 1, 1, 1],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 0, 1, 0],
           [0, 0, 1, 0],
           [0, 0, 1, 0],
           [0, 0, 1, 0]]
        ],
        O: [
          [[0, 1, 1, 0],
           [0, 1, 1, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]]
        ],
        T: [
          [[0, 1, 0, 0],
           [1, 1, 1, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 1, 0, 0],
           [0, 1, 1, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]],
          [[0, 0, 0, 0],
           [1, 1, 1, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]],
          [[0, 1, 0, 0],
           [1, 1, 0, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]]
        ],
        S: [
          [[0, 1, 1, 0],
           [1, 1, 0, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 1, 0, 0],
           [0, 1, 1, 0],
           [0, 0, 1, 0],
           [0, 0, 0, 0]]
        ],
        Z: [
          [[1, 1, 0, 0],
           [0, 1, 1, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 0, 1, 0],
           [0, 1, 1, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]]
        ],
        J: [
          [[1, 0, 0, 0],
           [1, 1, 1, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 1, 1, 0],
           [0, 1, 0, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]],
          [[0, 0, 0, 0],
           [1, 1, 1, 0],
           [0, 0, 1, 0],
           [0, 0, 0, 0]],
          [[0, 1, 0, 0],
           [0, 1, 0, 0],
           [1, 1, 0, 0],
           [0, 0, 0, 0]]
        ],
        L: [
          [[0, 0, 1, 0],
           [1, 1, 1, 0],
           [0, 0, 0, 0],
           [0, 0, 0, 0]],
          [[0, 1, 0, 0],
           [0, 1, 0, 0],
           [0, 1, 1, 0],
           [0, 0, 0, 0]],
          [[0, 0, 0, 0],
           [1, 1, 1, 0],
           [1, 0, 0, 0],
           [0, 0, 0, 0]],
          [[1, 1, 0, 0],
           [0, 1, 0, 0],
           [0, 1, 0, 0],
           [0, 0, 0, 0]]
        ]
      };

      const COLORS = {
        I: "#22d3ee",
        O: "#fbbf24",
        T: "#a855f7",
        S: "#22c55e",
        Z: "#ef4444",
        J: "#3b82f6",
        L: "#f97316"
      };

      let grid = createGrid();
      let currentPiece = null;
      let nextPiece = null;
      let score = 0;
      let lines = 0;
      let bestScore = 0;
      let isRunning = false;
      let isGameOver = false;
      let lastTime = 0;
      let dropCounter = 0;
      let dropInterval = 800; // ms
      let animationId = null;

      try {
        const saved = localStorage.getItem("neon-tetris-best");
        if (saved) {
          bestScore = parseInt(saved, 10) || 0;
        }
      } catch (e) {}
      bestScoreEl.textContent = bestScore;
      overlayBestEl.textContent = bestScore;

      function createGrid() {
        const g = [];
        for (let r = 0; r < ROWS; r++) {
          const row = new Array(COLS).fill(null);
          g.push(row);
        }
        return g;
      }

      function randomPiece() {
        const keys = Object.keys(SHAPES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        return {
          type,
          rotationIndex: 0,
          matrix: SHAPES[type][0],
          x: 3,
          y: -1
        };
      }

      function resetGame() {
        grid = createGrid();
        score = 0;
        lines = 0;
        dropInterval = 800;
        scoreEl.textContent = score;
        linesEl.textContent = lines;
        currentPiece = randomPiece();
        nextPiece = randomPiece();
        isGameOver = false;
        updateStatus("游戏中 · 祝你好运");
        overlay.classList.add("hidden");
        draw();
        drawNext();
      }

      function updateStatus(text) {
        statusText.textContent = text;
      }

      function insideGrid(x, y) {
        return x >= 0 && x < COLS && y < ROWS;
      }

      function collide(piece, offsetX = 0, offsetY = 0, matrixOverride = null) {
        const m = matrixOverride || piece.matrix;
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const nx = piece.x + c + offsetX;
            const ny = piece.y + r + offsetY;
            if (ny < 0) continue;
            if (!insideGrid(nx, ny) || grid[ny][nx]) {
              return true;
            }
          }
        }
        return false;
      }

      function merge(piece) {
        const m = piece.matrix;
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const x = piece.x + c;
            const y = piece.y + r;
            if (y < 0) continue;
            if (insideGrid(x, y)) {
              grid[y][x] = piece.type;
            }
          }
        }
      }

      function clearLines() {
        let linesCleared = 0;
        for (let r = ROWS - 1; r >= 0; ) {
          if (grid[r].every(cell => cell)) {
            grid.splice(r, 1);
            grid.unshift(new Array(COLS).fill(null));
            linesCleared++;
          } else {
            r--;
          }
        }

        if (linesCleared > 0) {
          lines += linesCleared;
          linesEl.textContent = lines;
          let addScore = 0;
          if (linesCleared === 1) addScore = 100;
          else if (linesCleared === 2) addScore = 300;
          else if (linesCleared === 3) addScore = 500;
          else if (linesCleared >= 4) addScore = 800;
          score += addScore;
          scoreEl.textContent = score;

          if (score > bestScore) {
            bestScore = score;
            bestScoreEl.textContent = bestScore;
            overlayBestEl.textContent = bestScore;
            try {
              localStorage.setItem("neon-tetris-best", String(bestScore));
            } catch (e) {}
          }

          // 随清行数逐步提速
          const speedUp = linesCleared * 20;
          dropInterval = Math.max(120, dropInterval - speedUp);
        }
      }

      function rotatePiece() {
        if (!currentPiece) return;
        const shapeRotations = SHAPES[currentPiece.type];
        const nextIndex = (currentPiece.rotationIndex + 1) % shapeRotations.length;
        const nextMatrix = shapeRotations[nextIndex];

        if (!collide(currentPiece, 0, 0, nextMatrix)) {
          currentPiece.rotationIndex = nextIndex;
          currentPiece.matrix = nextMatrix;
        } else if (!collide(currentPiece, -1, 0, nextMatrix)) {
          currentPiece.x -= 1;
          currentPiece.rotationIndex = nextIndex;
          currentPiece.matrix = nextMatrix;
        } else if (!collide(currentPiece, 1, 0, nextMatrix)) {
          currentPiece.x += 1;
          currentPiece.rotationIndex = nextIndex;
          currentPiece.matrix = nextMatrix;
        }
      }

      function drop() {
        if (!currentPiece) return;
        if (!collide(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else {
          merge(currentPiece);
          clearLines();
          currentPiece = nextPiece;
          nextPiece = randomPiece();
          drawNext();

          if (collide(currentPiece, 0, 0)) {
            endGame();
          }
        }
      }

      function hardDrop() {
        if (!currentPiece) return;
        let dropDistance = 0;
        while (!collide(currentPiece, 0, 1)) {
          currentPiece.y++;
          dropDistance++;
        }
        if (dropDistance > 0) {
          score += dropDistance * 2;
          scoreEl.textContent = score;
        }
        drop();
      }

      function move(offsetX) {
        if (!currentPiece) return;
        if (!collide(currentPiece, offsetX, 0)) {
          currentPiece.x += offsetX;
        }
      }

      function drawBackground() {
        const w = canvas.width;
        const h = canvas.height;
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, "rgba(15, 23, 42, 0.9)");
        gradient.addColorStop(1, "rgba(15, 23, 42, 1)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        ctx.save();
        ctx.strokeStyle = "rgba(148, 163, 184, 0.08)";
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * BLOCK_SIZE + 0.5, 0);
          ctx.lineTo(x * BLOCK_SIZE + 0.5, h);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * BLOCK_SIZE + 0.5);
          ctx.lineTo(w, y * BLOCK_SIZE + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawCell(x, y, type, ghost = false) {
        const color = COLORS[type] || "#e5e7eb";
        const px = x * BLOCK_SIZE;
        const py = y * BLOCK_SIZE;
        const r = 5;

        ctx.save();
        const base = ctx.createLinearGradient(px, py, px, py + BLOCK_SIZE);
        if (!ghost) {
          base.addColorStop(0, lighten(color, 0.25));
          base.addColorStop(1, darken(color, 0.2));
        } else {
          base.addColorStop(0, hexToRgba(color, 0.18));
          base.addColorStop(1, hexToRgba(color, 0.05));
        }

        ctx.fillStyle = base;
        ctx.beginPath();
        ctx.roundRect(px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4, r);
        ctx.fill();

        if (!ghost) {
          ctx.strokeStyle = hexToRgba("#f9fafb", 0.7);
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(px + 4, py + 4);
          ctx.lineTo(px + BLOCK_SIZE - 6, py + 4);
          ctx.strokeStyle = hexToRgba("#ffffff", 0.5);
          ctx.lineWidth = 1;
          ctx.stroke();
        } else {
          ctx.strokeStyle = hexToRgba(color, 0.3);
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        ctx.restore();
      }

      function getGhostPiece() {
        if (!currentPiece) return null;
        const ghost = {
          x: currentPiece.x,
          y: currentPiece.y,
          matrix: currentPiece.matrix,
          type: currentPiece.type
        };
        while (!collide(ghost, 0, 1)) {
          ghost.y++;
        }
        return ghost;
      }

      function draw() {
        drawBackground();

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const type = grid[r][c];
            if (type) {
              drawCell(c, r, type, false);
            }
          }
        }

        const ghost = getGhostPiece();
        if (ghost) {
          const m = ghost.matrix;
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
              if (!m[r][c]) continue;
              const x = ghost.x + c;
              const y = ghost.y + r;
              if (y < 0) continue;
              drawCell(x, y, ghost.type, true);
            }
          }
        }

        if (currentPiece) {
          const m = currentPiece.matrix;
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
              if (!m[r][c]) continue;
              const x = currentPiece.x + c;
              const y = currentPiece.y + r;
              if (y < 0) continue;
              drawCell(x, y, currentPiece.type, false);
            }
          }
        }
      }

      function drawNext() {
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        if (!nextPiece) return;
        const size = BLOCK_SIZE - 4;
        const offsetX = (nextCanvas.width - 4 * size) / 2;
        const offsetY = (nextCanvas.height - 4 * size) / 2;

        const m = nextPiece.matrix;
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const px = offsetX + c * size;
            const py = offsetY + r * size;
            const color = COLORS[nextPiece.type];

            nextCtx.save();
            const gradient = nextCtx.createLinearGradient(px, py, px, py + size);
            gradient.addColorStop(0, lighten(color, 0.25));
            gradient.addColorStop(1, darken(color, 0.2));
            nextCtx.fillStyle = gradient;
            nextCtx.beginPath();
            nextCtx.roundRect(px + 2, py + 2, size - 4, size - 4, 5);
            nextCtx.fill();
            nextCtx.strokeStyle = hexToRgba("#f9fafb", 0.7);
            nextCtx.lineWidth = 1;
            nextCtx.stroke();
            nextCtx.restore();
          }
        }
      }

      function hexToRgba(hex, alpha) {
        const c = hex.replace("#", "");
        const num = parseInt(c, 16);
        const r = (num >> 16) & 255;
        const g = (num >> 8) & 255;
        const b = num & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function lighten(hex, amount) {
        const c = hex.replace("#", "");
        const num = parseInt(c, 16);
        let r = (num >> 16) & 255;
        let g = (num >> 8) & 255;
        let b = num & 255;
        r = Math.min(255, Math.floor(r + 255 * amount));
        g = Math.min(255, Math.floor(g + 255 * amount));
        b = Math.min(255, Math.floor(b + 255 * amount));
        return `rgb(${r}, ${g}, ${b})`;
      }

      function darken(hex, amount) {
        const c = hex.replace("#", "");
        const num = parseInt(c, 16);
        let r = (num >> 16) & 255;
        let g = (num >> 8) & 255;
        let b = num & 255;
        r = Math.max(0, Math.floor(r * (1 - amount)));
        g = Math.max(0, Math.floor(g * (1 - amount)));
        b = Math.max(0, Math.floor(b * (1 - amount)));
        return `rgb(${r}, ${g}, ${b})`;
      }

      function update(time = 0) {
        if (!isRunning) return;
        const delta = time - lastTime;
        lastTime = time;
        dropCounter += delta;
        if (dropCounter > dropInterval) {
          drop();
          dropCounter = 0;
        }
        draw();
        animationId = requestAnimationFrame(update);
      }

      function startGame() {
        if (isRunning) return;
        if (!currentPiece || isGameOver) {
          resetGame();
        }
        isRunning = true;
        isGameOver = false;
        overlay.classList.add("hidden");
        pauseBtn.textContent = "⏸ 暂停";
        updateStatus("游戏中 · P 键可暂停");
        lastTime = performance.now();
        dropCounter = 0;
        if (animationId) cancelAnimationFrame(animationId);
        animationId = requestAnimationFrame(update);
      }

      function pauseGame() {
        if (!isRunning) return;
        isRunning = false;
        if (animationId) cancelAnimationFrame(animationId);
        overlayTitle.textContent = "暂停中";
        overlaySubtitle.textContent = "按 P 键或空格继续";
        overlayScoreEl.textContent = score;
        overlay.classList.remove("hidden");
        pauseBtn.textContent = "▶ 继续";
        updateStatus("已暂停 · 按 P 键继续");
      }

      function togglePause() {
        if (!isRunning && !isGameOver && currentPiece) {
          startGame();
        } else if (isRunning) {
          pauseGame();
        }
      }

      function endGame() {
        isRunning = false;
        isGameOver = true;
        if (animationId) cancelAnimationFrame(animationId);
        overlayTitle.textContent = "Game Over";
        overlaySubtitle.textContent = "按回车重新开始";
        overlayScoreEl.textContent = score;
        overlayBestEl.textContent = bestScore;
        overlay.classList.remove("hidden");
        pauseBtn.textContent = "⏸ 暂停";
        updateStatus("游戏结束 · 按回车重新开始");
      }

      function handleKeydown(e) {
        const key = e.key.toLowerCase();

        // P键：暂停/继续
        if (key === "p") {
          togglePause();
          e.preventDefault();
          return;
        }

        // 回车键：开始游戏（如果未运行）
        if (key === "enter") {
          if (!isRunning) {
            startGame();
          }
          e.preventDefault();
          return;
        }

        // 空格键：游戏运行时快速下落，未运行时开始/继续游戏
        if (key === " ") {
          if (!isRunning) {
            // 未运行时：开始新游戏或继续已暂停的游戏
            if (isGameOver || !currentPiece) {
              startGame();
            } else {
              // 已暂停状态，继续游戏
              startGame();
            }
          } else {
            // 游戏运行时，执行快速下落
            if (currentPiece && !isGameOver) {
              hardDrop();
            }
          }
          e.preventDefault();
          return;
        }

        if (!isRunning || !currentPiece || isGameOver) return;

        if (key === "arrowleft" || key === "a") {
          move(-1);
        } else if (key === "arrowright" || key === "d") {
          move(1);
        } else if (key === "arrowdown" || key === "s") {
          if (!collide(currentPiece, 0, 1)) {
            currentPiece.y++;
            dropCounter = 0;
          }
        } else if (key === "arrowup" || key === "w") {
          rotatePiece();
        }
        draw();
      }

      document.addEventListener("keydown", handleKeydown);

      pauseBtn.addEventListener("click", () => {
        if (!currentPiece || isGameOver) {
          startGame();
        } else {
          togglePause();
        }
      });

      restartBtn.addEventListener("click", () => {
        resetGame();
        startGame();
      });

      overlay.addEventListener("click", () => {
        startGame();
      });

      // 初始化静态画面
      currentPiece = randomPiece();
      nextPiece = randomPiece();
      draw();
      drawNext();
      updateStatus("等待开始 · 按回车开始");
    })();
  </script>
</body>
</html>


